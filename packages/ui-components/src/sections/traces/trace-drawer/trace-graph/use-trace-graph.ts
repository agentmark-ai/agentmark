import { useMemo } from "react";
import { GraphEdge, GraphNode } from "./use-graph-data";
import {
  generateWorkflowGraph,
  hasManualGraphMetadata,
  type WorkflowNode,
  type WorkflowEdge,
} from "./workflow-graph-generator";
import type { SpanForGrouping } from "../../utils/span-grouping";

export interface GraphData {
  parentNodeId?: string;
  nodeId: string;
  spanId: string;
  nodeType: string;
  displayName: string;
  spanName: string;
}

/**
 * Extended GraphData that includes auto-generation fields.
 * Backward compatible with existing GraphData.
 */
export interface ExtendedGraphData extends GraphData {
  /** All span IDs in this node (auto-generated only) */
  spanIds?: string[];
  /** Number of spans (auto-generated only) */
  spanCount?: number;
}

/**
 * Extended GraphNode with auto-generation fields.
 */
export interface ExtendedGraphNode extends GraphNode {
  /** All span IDs for click cycling */
  spanIds?: string[];
  /** Number of spans (for badge display) */
  spanCount?: number;
}

/**
 * Result of useTraceGraph hook.
 */
export interface UseTraceGraphResult {
  nodes: ExtendedGraphNode[];
  edges: GraphEdge[];
  /** True if graph was auto-generated from spans */
  isAutoGenerated: boolean;
}

/**
 * Processes manual graph data (existing functionality).
 * Used when spans have graph.node.* metadata.
 */
function processManualGraphData(graphData: GraphData[]): UseTraceGraphResult {
  const nodes: ExtendedGraphNode[] = [];
  const edges: GraphEdge[] = [];
  const seenNodes = new Set<string>();
  const seenEdges = new Set<string>();

  graphData.forEach(
    ({
      displayName,
      nodeId,
      nodeType,
      parentNodeId: parentId = "",
      spanId,
      spanName,
    }) => {
      if (nodeId && !seenNodes.has(nodeId)) {
        seenNodes.add(nodeId);
        nodes.push({
          id: nodeId,
          spanId,
          label: displayName || spanName || nodeId,
          nodeType,
          spanIds: [spanId],
          spanCount: 1,
        });
      }

      if (parentId && parentId.trim() !== "" && nodeId) {
        const edgeKey = `${parentId}->${nodeId}`;
        if (!seenEdges.has(edgeKey)) {
          seenEdges.add(edgeKey);
          edges.push({ id: edgeKey, source: parentId, target: nodeId });
        }
      }
    }
  );

  return { nodes, edges, isAutoGenerated: false };
}

/**
 * Converts auto-generated workflow nodes to graph nodes.
 */
function convertWorkflowNodesToGraphNodes(
  workflowNodes: WorkflowNode[]
): ExtendedGraphNode[] {
  return workflowNodes.map((node) => ({
    id: node.nodeId,
    spanId: node.spanIds[0] || "",
    label: node.displayName,
    nodeType: node.nodeType,
    spanIds: node.spanIds,
    spanCount: node.spanIds.length,
  }));
}

/**
 * Converts auto-generated workflow edges to graph edges.
 */
function convertWorkflowEdgesToGraphEdges(
  workflowEdges: WorkflowEdge[]
): GraphEdge[] {
  return workflowEdges.map((edge) => ({
    id: edge.id,
    source: edge.source,
    target: edge.target,
    bidirectional: edge.bidirectional,
  }));
}

/**
 * Hook to generate graph nodes and edges from trace data.
 *
 * Supports two modes:
 * 1. Manual graph metadata: Uses existing graph.node.* attributes (backward compatible)
 * 2. Auto-generation: Groups spans by {parentSpanId, spanName} and generates edges
 *
 * @param graphData - Manual graph data from span attributes (can be empty)
 * @param spans - Optional span data for auto-generation
 * @returns Graph nodes, edges, and auto-generation flag
 */
export const useTraceGraph = (
  graphData: GraphData[],
  spans?: SpanForGrouping[]
): UseTraceGraphResult => {
  const result = useMemo(() => {
    // Priority 1: Use manual graph data if present (backward compatibility)
    if (graphData && graphData.length > 0) {
      return processManualGraphData(graphData);
    }

    // Priority 2: Auto-generate from spans if available
    if (spans && spans.length > 0) {
      // Check if spans have manual metadata (should use manual path)
      if (hasManualGraphMetadata(spans)) {
        // This shouldn't happen if graphData is correctly extracted,
        // but handle it gracefully
        return { nodes: [], edges: [], isAutoGenerated: false };
      }

      try {
        const workflowGraph = generateWorkflowGraph(spans);
        return {
          nodes: convertWorkflowNodesToGraphNodes(workflowGraph.nodes),
          edges: convertWorkflowEdgesToGraphEdges(workflowGraph.edges),
          isAutoGenerated: true,
        };
      } catch (e) {
        console.error("Failed to generate workflow graph:", e);
        return { nodes: [], edges: [], isAutoGenerated: false };
      }
    }

    // No data available
    return { nodes: [], edges: [], isAutoGenerated: false };
  }, [graphData, spans]);

  return result;
};
