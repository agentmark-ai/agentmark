/**
 * Workflow Graph Generator
 *
 * Automatically generates workflow graph nodes and edges from span data
 * by grouping spans with the same name under the same parent.
 */

import {
  groupSpansByKey,
  inferNodeType,
  getDisplayName,
  type SpanForGrouping,
  type WorkflowNodeType,
} from "../../utils/span-grouping";

/**
 * Workflow node representing a grouped set of spans
 */
export interface WorkflowNode {
  /** Unique node identifier: `${parentSpanId || 'root'}:${spanName}` */
  nodeId: string;
  /** Human-readable label for display */
  displayName: string;
  /** Inferred operation type for styling */
  nodeType: WorkflowNodeType;
  /** All span IDs grouped in this node */
  spanIds: string[];
  /** Parent node ID for hierarchy (undefined for root nodes) */
  parentNodeId?: string;
}

/**
 * Workflow edge representing execution flow between nodes
 */
export interface WorkflowEdge {
  /** Edge identifier: `${source}->${target}` */
  id: string;
  /** Source node ID */
  source: string;
  /** Target node ID */
  target: string;
  /** True if both A->B and B->A transitions occurred */
  bidirectional: boolean;
}

/**
 * Result of workflow graph generation
 */
export interface WorkflowGraphResult {
  nodes: WorkflowNode[];
  edges: WorkflowEdge[];
  /** True if graph was auto-generated */
  isAutoGenerated: boolean;
}

/**
 * Checks if spans have manual graph metadata (graph.node.* attributes).
 * If manual metadata exists, we should use it instead of auto-generation.
 *
 * @param spans - Array of spans to check
 * @returns true if any span has manual graph metadata
 */
export function hasManualGraphMetadata(spans: SpanForGrouping[]): boolean {
  return spans.some((span) => {
    const data = span.data as Record<string, unknown> | undefined;
    if (!data) return false;

    // Check for graph.node.* attributes in span data
    return Object.keys(data).some(
      (key) =>
        key.startsWith("graph.node.") ||
        key === "graphNodeId" ||
        key === "graphNodeType"
    );
  });
}

/**
 * Generates edges based on execution order transitions between nodes.
 *
 * Algorithm:
 * 1. Sort spans by startTime within each parent
 * 2. For consecutive spans A → B under same parent, create edge from A's node to B's node
 * 3. Track seen transitions to create bidirectional edges when A→B and B→A both occur
 * 4. Don't create edge if both spans belong to same node
 * 5. Create hierarchical edges from parent nodes to their first child node
 *
 * @param spans - All spans in the trace
 * @param nodeKeysBySpanId - Map of spanId to nodeId
 * @returns Array of workflow edges
 */
export function generateExecutionEdges(
  spans: SpanForGrouping[],
  nodeKeysBySpanId: Map<string, string>
): WorkflowEdge[] {
  // Group spans by parent for ordering
  const spansByParent = new Map<string, SpanForGrouping[]>();
  for (const span of spans) {
    const parentKey = span.parentSpanId || "root";
    const existing = spansByParent.get(parentKey) || [];
    existing.push(span);
    spansByParent.set(parentKey, existing);
  }

  // Track edges: key is normalized (alphabetical), value includes actual first direction
  const edgeTransitions = new Map<
    string,
    {
      forward: boolean;
      backward: boolean;
      firstSource: string;
      firstTarget: string;
    }
  >();

  // Helper to add an edge transition
  const addEdgeTransition = (sourceNode: string, targetNode: string) => {
    // Create normalized edge key (always alphabetically for deduplication)
    const [first, second] = [sourceNode, targetNode].sort();
    const edgeKey = `${first}->${second}`;

    const existing = edgeTransitions.get(edgeKey);

    if (!existing) {
      // First time seeing this edge pair - record the actual direction
      edgeTransitions.set(edgeKey, {
        forward: first === sourceNode,
        backward: first !== sourceNode,
        firstSource: sourceNode,
        firstTarget: targetNode,
      });
    } else {
      // Update direction flags
      if (first === sourceNode) {
        existing.forward = true;
      } else {
        existing.backward = true;
      }
    }
  };

  // Process each parent's children
  for (const [parentSpanId, parentSpans] of spansByParent) {
    // Sort by start time
    const sorted = [...parentSpans].sort((a, b) => a.startTime - b.startTime);

    // Create hierarchical edge from parent node to first child node
    if (parentSpanId !== "root" && sorted.length > 0) {
      const parentNode = nodeKeysBySpanId.get(parentSpanId);
      const firstChildSpan = sorted[0];
      const firstChildNode = firstChildSpan ? nodeKeysBySpanId.get(firstChildSpan.spanId) : undefined;

      if (parentNode && firstChildNode && parentNode !== firstChildNode) {
        addEdgeTransition(parentNode, firstChildNode);
      }
    }

    // Create edges between consecutive spans (execution flow)
    for (let i = 0; i < sorted.length - 1; i++) {
      const currentSpan = sorted[i];
      const nextSpan = sorted[i + 1];

      const currentNode = nodeKeysBySpanId.get(currentSpan!.spanId);
      const nextNode = nodeKeysBySpanId.get(nextSpan!.spanId);

      // Skip if same node (spans in same group)
      if (!currentNode || !nextNode || currentNode === nextNode) {
        continue;
      }

      addEdgeTransition(currentNode, nextNode);
    }
  }

  // Convert to WorkflowEdge array using the first observed direction
  const edges: WorkflowEdge[] = [];
  for (const [edgeKey, data] of edgeTransitions) {
    edges.push({
      id: edgeKey,
      source: data.firstSource,
      target: data.firstTarget,
      bidirectional: data.forward && data.backward,
    });
  }

  return edges;
}

/**
 * Main workflow graph generator.
 * Groups spans by {parentSpanId, spanName} and generates edges based on execution order.
 *
 * @param spans - Array of spans to process
 * @returns WorkflowGraphResult with nodes, edges, and metadata
 */
export function generateWorkflowGraph(
  spans: SpanForGrouping[]
): WorkflowGraphResult {
  if (!spans || spans.length === 0) {
    return { nodes: [], edges: [], isAutoGenerated: true };
  }

  // Group spans by key
  const groups = groupSpansByKey(spans);

  // Build spanId -> nodeKey map for edge generation
  const nodeKeysBySpanId = new Map<string, string>();
  for (const [key, group] of groups) {
    for (const spanId of group.spanIds) {
      nodeKeysBySpanId.set(spanId, key);
    }
  }

  // Determine which groups have children (for agent detection)
  const groupsWithChildren = new Set<string>();
  for (const span of spans) {
    if (span.parentSpanId) {
      const parentGroup = nodeKeysBySpanId.get(span.parentSpanId);
      if (parentGroup) {
        groupsWithChildren.add(parentGroup);
      }
    }
  }

  // Create nodes from groups
  const nodes: WorkflowNode[] = [];
  for (const [key, group] of groups) {
    // Get first span for type inference
    const firstSpan = spans.find((s) => s.spanId === group.spanIds[0]);
    if (!firstSpan) continue;

    const hasChildren = groupsWithChildren.has(key);

    nodes.push({
      nodeId: key,
      displayName: getDisplayName(group.spanName),
      nodeType: inferNodeType(firstSpan, hasChildren),
      spanIds: group.spanIds,
      parentNodeId: group.parentSpanId
        ? nodeKeysBySpanId.get(group.parentSpanId)
        : undefined,
    });
  }

  // Generate edges
  const edges = generateExecutionEdges(spans, nodeKeysBySpanId);

  // Find first and last nodes by span time for start/end connections
  const firstNodeId = findFirstNodeByTime(spans, nodeKeysBySpanId);
  const lastNodeId = findLastNodeByTime(spans, nodeKeysBySpanId);

  // Add start and end nodes
  const { nodes: finalNodes, edges: finalEdges } = addStartEndNodes(
    nodes,
    edges,
    firstNodeId,
    lastNodeId
  );

  return {
    nodes: finalNodes,
    edges: finalEdges,
    isAutoGenerated: true,
  };
}

/**
 * Finds the node containing the earliest span by startTime.
 */
function findFirstNodeByTime(
  spans: SpanForGrouping[],
  nodeKeysBySpanId: Map<string, string>
): string | undefined {
  if (spans.length === 0) return undefined;

  const sorted = [...spans].sort((a, b) => a.startTime - b.startTime);
  const firstSpan = sorted[0];
  return firstSpan ? nodeKeysBySpanId.get(firstSpan.spanId) : undefined;
}

/**
 * Finds the node containing the latest span by startTime.
 */
function findLastNodeByTime(
  spans: SpanForGrouping[],
  nodeKeysBySpanId: Map<string, string>
): string | undefined {
  if (spans.length === 0) return undefined;

  const sorted = [...spans].sort((a, b) => b.startTime - a.startTime);
  const lastSpan = sorted[0];
  return lastSpan ? nodeKeysBySpanId.get(lastSpan.spanId) : undefined;
}

/** Node ID for the synthetic start node */
export const START_NODE_ID = "__start__";
/** Node ID for the synthetic end node */
export const END_NODE_ID = "__end__";

/**
 * Adds synthetic start and end nodes to the workflow graph.
 *
 * - Start node connects to the first node (by time) or all root nodes if not specified
 * - End node receives edge from the last node (by time) or all leaf nodes if not specified
 *
 * @param nodes - Existing workflow nodes
 * @param edges - Existing workflow edges
 * @param firstNodeId - Node ID containing the earliest span (optional)
 * @param lastNodeId - Node ID containing the latest span (optional)
 * @returns Updated nodes and edges arrays with start/end nodes
 */
export function addStartEndNodes(
  nodes: WorkflowNode[],
  edges: WorkflowEdge[],
  firstNodeId?: string,
  lastNodeId?: string
): { nodes: WorkflowNode[]; edges: WorkflowEdge[] } {
  if (nodes.length === 0) {
    return { nodes: [], edges: [] };
  }

  // Create start node
  const startNode: WorkflowNode = {
    nodeId: START_NODE_ID,
    displayName: "",
    nodeType: "start",
    spanIds: [],
  };

  // Create end node
  const endNode: WorkflowNode = {
    nodeId: END_NODE_ID,
    displayName: "",
    nodeType: "end",
    spanIds: [],
  };

  // Create edge from start to first node
  const startEdges: WorkflowEdge[] = [];
  if (firstNodeId) {
    startEdges.push({
      id: `${START_NODE_ID}->${firstNodeId}`,
      source: START_NODE_ID,
      target: firstNodeId,
      bidirectional: false,
    });
  } else {
    // Fallback: connect to all root nodes (no incoming edges)
    const nodesWithIncoming = new Set<string>();
    for (const edge of edges) {
      nodesWithIncoming.add(edge.target);
    }
    const rootNodes = nodes.filter((node) => !nodesWithIncoming.has(node.nodeId));
    for (const node of rootNodes) {
      startEdges.push({
        id: `${START_NODE_ID}->${node.nodeId}`,
        source: START_NODE_ID,
        target: node.nodeId,
        bidirectional: false,
      });
    }
  }

  // Create edge from last node to end
  const endEdges: WorkflowEdge[] = [];
  if (lastNodeId) {
    endEdges.push({
      id: `${lastNodeId}->${END_NODE_ID}`,
      source: lastNodeId,
      target: END_NODE_ID,
      bidirectional: false,
    });
  } else {
    // Fallback: connect from all leaf nodes (no outgoing edges)
    const nodesWithOutgoing = new Set<string>();
    for (const edge of edges) {
      nodesWithOutgoing.add(edge.source);
    }
    const leafNodes = nodes.filter((node) => !nodesWithOutgoing.has(node.nodeId));
    for (const node of leafNodes) {
      endEdges.push({
        id: `${node.nodeId}->${END_NODE_ID}`,
        source: node.nodeId,
        target: END_NODE_ID,
        bidirectional: false,
      });
    }
  }

  return {
    nodes: [startNode, ...nodes, endNode],
    edges: [...startEdges, ...edges, ...endEdges],
  };
}
