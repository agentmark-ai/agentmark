/**
 * Unit tests for workflow graph generator
 * Tests the generateWorkflowGraph and generateExecutionEdges functions
 */

import { describe, it, expect } from "vitest";
import {
  generateWorkflowGraph,
  generateExecutionEdges,
  hasManualGraphMetadata,
} from "../../src/sections/traces/trace-drawer/trace-graph/workflow-graph-generator";
import type { SpanForGrouping } from "../../src/sections/traces/utils/span-grouping";

describe("workflow-graph-generator", () => {
  describe("hasManualGraphMetadata", () => {
    it("returns true when span has graph.node.id", () => {
      const spans: SpanForGrouping[] = [
        {
          spanId: "span-1",
          name: "generateText",
          startTime: 100,
          data: { "graph.node.id": "node-1" },
        },
      ];

      expect(hasManualGraphMetadata(spans)).toBe(true);
    });

    it("returns true when span has graphNodeId", () => {
      const spans: SpanForGrouping[] = [
        {
          spanId: "span-1",
          name: "generateText",
          startTime: 100,
          data: { graphNodeId: "node-1" },
        },
      ];

      expect(hasManualGraphMetadata(spans)).toBe(true);
    });

    it("returns false when no graph metadata", () => {
      const spans: SpanForGrouping[] = [
        {
          spanId: "span-1",
          name: "generateText",
          startTime: 100,
          data: { type: "GENERATION" },
        },
      ];

      expect(hasManualGraphMetadata(spans)).toBe(false);
    });

    it("returns false for spans without data", () => {
      const spans: SpanForGrouping[] = [
        {
          spanId: "span-1",
          name: "generateText",
          startTime: 100,
        },
      ];

      expect(hasManualGraphMetadata(spans)).toBe(false);
    });
  });

  describe("generateExecutionEdges", () => {
    it("creates edges between consecutive spans", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", parentSpanId: "root", name: "generateText", startTime: 100 },
        { spanId: "span-2", parentSpanId: "root", name: "search_web", startTime: 200 },
        { spanId: "span-3", parentSpanId: "root", name: "generateText", startTime: 300 },
      ];

      const nodeKeysBySpanId = new Map([
        ["span-1", "root:generateText"],
        ["span-2", "root:search_web"],
        ["span-3", "root:generateText"],
      ]);

      const edges = generateExecutionEdges(spans, nodeKeysBySpanId);

      // Should have edges: generateText -> search_web and search_web -> generateText
      expect(edges.length).toBe(1); // Combined into one bidirectional edge

      const edge = edges[0];
      expect(edge?.bidirectional).toBe(true);
    });

    it("does not create edges within same node", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", parentSpanId: "root", name: "generateText", startTime: 100 },
        { spanId: "span-2", parentSpanId: "root", name: "generateText", startTime: 200 },
      ];

      const nodeKeysBySpanId = new Map([
        ["span-1", "root:generateText"],
        ["span-2", "root:generateText"],
      ]);

      const edges = generateExecutionEdges(spans, nodeKeysBySpanId);

      expect(edges.length).toBe(0);
    });

    it("creates separate edges for different parents", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", parentSpanId: "parent-1", name: "A", startTime: 100 },
        { spanId: "span-2", parentSpanId: "parent-1", name: "B", startTime: 200 },
        { spanId: "span-3", parentSpanId: "parent-2", name: "C", startTime: 150 },
        { spanId: "span-4", parentSpanId: "parent-2", name: "D", startTime: 250 },
      ];

      const nodeKeysBySpanId = new Map([
        ["span-1", "parent-1:A"],
        ["span-2", "parent-1:B"],
        ["span-3", "parent-2:C"],
        ["span-4", "parent-2:D"],
      ]);

      const edges = generateExecutionEdges(spans, nodeKeysBySpanId);

      expect(edges.length).toBe(2);
    });

    it("handles empty spans array", () => {
      const edges = generateExecutionEdges([], new Map());
      expect(edges.length).toBe(0);
    });
  });

  describe("generateWorkflowGraph", () => {
    it("generates nodes and edges from spans", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", parentSpanId: "root", name: "generateText", startTime: 100, type: "GENERATION" },
        { spanId: "span-2", parentSpanId: "root", name: "search_web", startTime: 200 },
        { spanId: "span-3", parentSpanId: "root", name: "generateText", startTime: 300, type: "GENERATION" },
      ];

      const result = generateWorkflowGraph(spans);

      expect(result.isAutoGenerated).toBe(true);
      // 2 workflow nodes + 2 synthetic nodes (start, end)
      expect(result.nodes.length).toBe(4);
      // 1 bidirectional edge + 1 start edge + 1 end edge
      expect(result.edges.length).toBe(3);

      // Check workflow nodes (exclude start/end)
      const workflowNodes = result.nodes.filter((n) => n.nodeType !== "start" && n.nodeType !== "end");
      expect(workflowNodes.length).toBe(2);

      const generateTextNode = result.nodes.find((n) => n.displayName === "generateText");
      expect(generateTextNode).toBeDefined();
      expect(generateTextNode?.spanIds).toEqual(["span-1", "span-3"]);
      expect(generateTextNode?.nodeType).toBe("llm");

      const searchNode = result.nodes.find((n) => n.displayName === "search_web");
      expect(searchNode).toBeDefined();
      expect(searchNode?.spanIds).toEqual(["span-2"]);

      // Check start/end nodes exist
      const startNode = result.nodes.find((n) => n.nodeType === "start");
      const endNode = result.nodes.find((n) => n.nodeType === "end");
      expect(startNode).toBeDefined();
      expect(endNode).toBeDefined();
    });

    it("infers node types correctly", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", name: "generateText", startTime: 100, type: "GENERATION" },
        { spanId: "span-2", name: "search_tool", startTime: 200, data: { toolCalls: '[{"name":"search"}]' } },
        { spanId: "span-3", name: "rag_retrieval", startTime: 300 },
      ];

      const result = generateWorkflowGraph(spans);

      const llmNode = result.nodes.find((n) => n.displayName === "generateText");
      expect(llmNode?.nodeType).toBe("llm");

      const toolNode = result.nodes.find((n) => n.displayName === "search_tool");
      expect(toolNode?.nodeType).toBe("tool");

      const retrievalNode = result.nodes.find((n) => n.displayName === "rag_retrieval");
      expect(retrievalNode?.nodeType).toBe("retrieval");
    });

    it("handles empty spans array", () => {
      const result = generateWorkflowGraph([]);

      expect(result.nodes.length).toBe(0);
      expect(result.edges.length).toBe(0);
      expect(result.isAutoGenerated).toBe(true);
    });

    it("creates bidirectional edges for A->B->A patterns", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", name: "llm", startTime: 100, type: "GENERATION" },
        { spanId: "span-2", name: "tool", startTime: 200 },
        { spanId: "span-3", name: "llm", startTime: 300, type: "GENERATION" },
        { spanId: "span-4", name: "tool", startTime: 400 },
        { spanId: "span-5", name: "llm", startTime: 500, type: "GENERATION" },
      ];

      const result = generateWorkflowGraph(spans);

      // 1 bidirectional edge + 1 start edge + 1 end edge = 3 edges
      expect(result.edges.length).toBe(3);

      // Find the bidirectional edge (excludes start/end edges)
      const bidirectionalEdge = result.edges.find(e => e.bidirectional);
      expect(bidirectionalEdge).toBeDefined();
      expect(bidirectionalEdge?.bidirectional).toBe(true);
    });

    it("groups spans correctly by parent and name", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "span-1", parentSpanId: "parent-1", name: "op", startTime: 100 },
        { spanId: "span-2", parentSpanId: "parent-1", name: "op", startTime: 200 },
        { spanId: "span-3", parentSpanId: "parent-2", name: "op", startTime: 300 },
      ];

      const result = generateWorkflowGraph(spans);

      // Should have 4 nodes: parent-1:op, parent-2:op + start + end
      expect(result.nodes.length).toBe(4);

      const parent1Node = result.nodes.find((n) => n.nodeId === "parent-1:op");
      expect(parent1Node?.spanIds).toEqual(["span-1", "span-2"]);

      const parent2Node = result.nodes.find((n) => n.nodeId === "parent-2:op");
      expect(parent2Node?.spanIds).toEqual(["span-3"]);

      // Verify start and end nodes exist
      const startNode = result.nodes.find((n) => n.nodeType === "start");
      const endNode = result.nodes.find((n) => n.nodeType === "end");
      expect(startNode).toBeDefined();
      expect(endNode).toBeDefined();
    });

    it("sets parentNodeId for nested spans", () => {
      const spans: SpanForGrouping[] = [
        { spanId: "agent", name: "agent_run", startTime: 100 },
        { spanId: "llm", parentSpanId: "agent", name: "generateText", startTime: 200 },
      ];

      const result = generateWorkflowGraph(spans);

      const agentNode = result.nodes.find((n) => n.displayName === "agent_run");
      expect(agentNode?.parentNodeId).toBeUndefined();

      // Note: parentNodeId links to the node that contains the parent span
      // This is used for nested subgraph rendering
    });
  });
});
