import { describe, it, expect } from 'vitest';
const jsdoc = require('json-schema-to-jsdoc');

// Import the functions we want to test
import type { PromptFrontmatter } from '../src/commands/generate-types';

// Re-create the helper functions from generate-types.ts for testing
function getInterfaceName(filePath: string): string {
  return filePath
    .replace(/\.prompt\.mdx$/, "")
    .split("/")
    .map((part) => {
      return part
        .split(/[-_]|(?=[A-Z])/)
        .map(
          (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        )
        .join("")
        .replace(/[^a-zA-Z0-9]/g, "");
    })
    .join("$");
}

function convertJsonSchemaToJSDoc(schema: any, typeName: string): string {
  if (!schema) {
    return `/**
 * @typedef {Object} ${typeName}
 */`;
  }

  // Add title to schema for proper typedef naming
  const schemaWithTitle = {
    ...schema,
    title: typeName
  };

  // Use json-schema-to-jsdoc package with options for proper formatting
  return jsdoc(schemaWithTitle, {
    hyphenatedDescriptions: true,
    capitalizeTitle: false
  });
}

async function generateJSDocDefinitions(prompts: any[]): Promise<string> {
  const headerComment = `/**
 * Auto-generated JSDoc definitions from AgentMark
 * Do not edit this file directly
 * 
 * Import this file in your .prompt.mdx files for type safety:
 * {/** @import {MyPromptProps} from './agentmark.jsdoc.js' */}
 */

`;

  let jsDocDefinitions: string[] = [];

  for (const prompt of prompts) {
    const { path: promptPath, input_schema } = prompt;
    const name = getInterfaceName(promptPath);
    const typeName = `${name}Props`;
    
    if (input_schema) {
      const jsDoc = convertJsonSchemaToJSDoc(input_schema, typeName);
      jsDocDefinitions.push(jsDoc);
    } else {
      // Generate a generic JSDoc if no schema
      const genericJSDoc = `/**
 * @typedef {Object} ${typeName}
 * @property {any} [key] - Generic props object for ${promptPath}
 */`;
      jsDocDefinitions.push(genericJSDoc);
    }
  }

  // Create a summary comment with all available types
  const availableTypes = prompts.map(prompt => {
    const name = getInterfaceName(prompt.path);
    return ` * - ${name}Props: Props for ${prompt.path}`;
  }).join('\n');

  const summaryComment = `
/**
 * Available JSDoc types for AgentMark prompts:
${availableTypes}
 * 
 * Usage in .prompt.mdx files:
 * {/** @import {PromptNameProps} from './agentmark.jsdoc.js' */}
 * {/** @param {PromptNameProps} props */}
 */`;

  return headerComment + jsDocDefinitions.join('\n\n') + '\n' + summaryComment;
}

describe('JSDoc Generation', () => {
  describe('getInterfaceName', () => {
    it('should convert simple prompt path to interface name', () => {
      expect(getInterfaceName('customer-support.prompt.mdx')).toBe('CustomerSupport');
    });

    it('should handle snake_case', () => {
      expect(getInterfaceName('user_profile.prompt.mdx')).toBe('UserProfile');
    });

    it('should handle camelCase', () => {
      expect(getInterfaceName('userProfile.prompt.mdx')).toBe('UserProfile');
    });

    it('should handle nested paths', () => {
      expect(getInterfaceName('auth/login-form.prompt.mdx')).toBe('Auth$LoginForm');
    });

    it('should handle complex paths', () => {
      expect(getInterfaceName('components/user-management/profile_edit.prompt.mdx')).toBe('Components$UserManagement$ProfileEdit');
    });
  });

  describe('convertJsonSchemaToJSDoc', () => {
    it('should handle empty schema', () => {
      const result = convertJsonSchemaToJSDoc(null, 'TestProps');
      expect(result).toContain('@typedef {Object} TestProps');
    });

    it('should convert simple string schema', () => {
      const schema = {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description: 'User name'
          }
        },
        required: ['name']
      };

      const result = convertJsonSchemaToJSDoc(schema, 'UserProps');
      expect(result).toContain('@typedef {object} UserProps');
      expect(result).toContain('@property {string} name - User name');
    });

    it('should handle optional properties', () => {
      const schema = {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description: 'User name'
          },
          age: {
            type: 'integer',
            description: 'User age'
          }
        },
        required: ['name']
      };

      const result = convertJsonSchemaToJSDoc(schema, 'UserProps');
      expect(result).toContain('@property {string} name - User name');
      expect(result).toContain('@property {integer} [age] - User age');
    });

    it('should handle array properties', () => {
      const schema = {
        type: 'object',
        properties: {
          tags: {
            type: 'array',
            items: {
              type: 'string'
            },
            description: 'User tags'
          }
        },
        required: ['tags']
      };

      const result = convertJsonSchemaToJSDoc(schema, 'UserProps');
      expect(result).toContain('@property {array} tags - User tags');
    });

    it('should handle nested objects', () => {
      const schema = {
        type: 'object',
        properties: {
          address: {
            type: 'object',
            properties: {
              street: { type: 'string' },
              city: { type: 'string' }
            },
            description: 'User address'
          }
        },
        required: ['address']
      };

      const result = convertJsonSchemaToJSDoc(schema, 'UserProps');
      expect(result).toContain('@typedef {object} UserProps');
      expect(result).toContain('address');
    });

    it('should handle boolean and number types', () => {
      const schema = {
        type: 'object',
        properties: {
          isActive: {
            type: 'boolean',
            description: 'Whether user is active'
          },
          score: {
            type: 'number',
            description: 'User score'
          },
          count: {
            type: 'integer',
            description: 'Item count'
          }
        },
        required: ['isActive']
      };

      const result = convertJsonSchemaToJSDoc(schema, 'UserProps');
      expect(result).toContain('@property {boolean} isActive - Whether user is active');
      expect(result).toContain('@property {number} [score] - User score');
      expect(result).toContain('@property {integer} [count] - Item count');
    });
  });

  describe('generateJSDocDefinitions', () => {
    it('should generate JSDoc for multiple prompts', async () => {
      const mockPrompts = [
        {
          path: 'customer-support.prompt.mdx',
          input_schema: {
            type: 'object',
            properties: {
              customer_question: {
                type: 'string',
                description: 'Customer question'
              },
              priority: {
                type: 'string',
                description: 'Priority level'
              }
            },
            required: ['customer_question']
          }
        },
        {
          path: 'math.prompt.mdx',
          input_schema: {
            type: 'object',
            properties: {
              problem: {
                type: 'string',
                description: 'Math problem to solve'
              }
            },
            required: ['problem']
          }
        }
      ];

      const result = await generateJSDocDefinitions(mockPrompts);

      // Should contain header comment
      expect(result).toContain('Auto-generated JSDoc definitions from AgentMark');
      expect(result).toContain('Do not edit this file directly');

      // Should contain typedef for each prompt
      expect(result).toContain('@typedef {object} CustomerSupportProps');
      expect(result).toContain('@typedef {object} MathProps');

      // Should contain properties with correct types and descriptions
      expect(result).toContain('@property {string} customer_question - Customer question');
      expect(result).toContain('@property {string} [priority] - Priority level');
      expect(result).toContain('@property {string} problem - Math problem to solve');

      // Should contain summary comment
      expect(result).toContain('Available JSDoc types for AgentMark prompts:');
      expect(result).toContain('CustomerSupportProps: Props for customer-support.prompt.mdx');
      expect(result).toContain('MathProps: Props for math.prompt.mdx');

      // Should contain usage instructions
      expect(result).toContain('Usage in .prompt.mdx files:');
      expect(result).toContain('@import {PromptNameProps}');
      expect(result).toContain('@param {PromptNameProps} props');
    });

    it('should handle prompts without input_schema', async () => {
      const mockPrompts = [
        {
          path: 'simple.prompt.mdx',
          input_schema: null
        },
        {
          path: 'another.prompt.mdx'
          // no input_schema property
        }
      ];

      const result = await generateJSDocDefinitions(mockPrompts);

      // Should generate generic JSDoc for prompts without schema
      expect(result).toContain('@typedef {Object} SimpleProps');
      expect(result).toContain('Generic props object for simple.prompt.mdx');
      expect(result).toContain('@typedef {Object} AnotherProps');
      expect(result).toContain('Generic props object for another.prompt.mdx');
    });

    it('should handle complex schemas with enums and unions', async () => {
      const mockPrompts = [
        {
          path: 'complex.prompt.mdx',
          input_schema: {
            type: 'object',
            properties: {
              status: {
                type: 'string',
                enum: ['active', 'inactive', 'pending'],
                description: 'Status of the item'
              },
              metadata: {
                type: 'object',
                description: 'Additional metadata'
              },
              items: {
                type: 'array',
                items: {
                  type: 'string'
                },
                description: 'List of items'
              }
            },
            required: ['status', 'items']
          }
        }
      ];

      const result = await generateJSDocDefinitions(mockPrompts);

      expect(result).toContain('@typedef {object} ComplexProps');
      expect(result).toContain('status');
      expect(result).toContain('metadata');
      expect(result).toContain('items');
    });

    it('should generate proper imports and usage instructions', async () => {
      const mockPrompts = [
        {
          path: 'test.prompt.mdx',
          input_schema: {
            type: 'object',
            properties: {
              input: { type: 'string' }
            },
            required: ['input']
          }
        }
      ];

      const result = await generateJSDocDefinitions(mockPrompts);

      // Check import instruction format
      expect(result).toContain('{/** @import {MyPromptProps} from \'./agentmark.jsdoc.js\' */}');
      
      // Check usage instructions
      expect(result).toContain('{/** @import {PromptNameProps} from \'./agentmark.jsdoc.js\' */}');
      expect(result).toContain('{/** @param {PromptNameProps} props */}');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty prompts array', async () => {
      const result = await generateJSDocDefinitions([]);
      
      expect(result).toContain('Auto-generated JSDoc definitions from AgentMark');
      expect(result).toContain('Available JSDoc types for AgentMark prompts:');
      // Should not crash and should still have proper structure
    });

    it('should handle special characters in file names', () => {
      expect(getInterfaceName('file-with@special#chars$.prompt.mdx')).toBe('FileWithspecialchars');
    });

    it('should handle very long file paths', () => {
      const longPath = 'very/long/path/with/many/nested/directories/final-component.prompt.mdx';
      const result = getInterfaceName(longPath);
      expect(result).toContain('Very$Long$Path$With$Many$Nested$Directories$FinalComponent');
    });
  });
});