import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import * as fs from "fs-extra";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

// Mock console.error to avoid noise in tests
const originalConsoleError = console.error;
beforeEach(() => {
  console.error = vi.fn();
});

afterEach(() => {
  console.error = originalConsoleError;
});

describe("generate-types CLI command", () => {
  const fixturesDir = path.resolve(__dirname, "fixtures");
  const tempDir = path.resolve(__dirname, "temp");
  const cliPath = path.resolve(__dirname, "../dist/src/index.js");

  beforeEach(async () => {
    // Ensure temp directory exists and is clean
    await fs.ensureDir(tempDir);
    await fs.emptyDir(tempDir);
  });

  afterEach(async () => {
    // Clean up temp directory
    await fs.remove(tempDir);
  });

  describe("TypeScript generation", () => {
    it("should generate TypeScript types for prompts with input schemas", async () => {
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${fixturesDir}`
      );

      // Check that TypeScript interfaces are generated
      expect(stdout).toContain("interface UserGreetingIn");
      expect(stdout).toContain("interface DataAnalysisIn");
      expect(stdout).toContain("interface SimplePromptIn");

      // Check that the UserGreeting interface has the correct properties
      expect(stdout).toContain("userName: string;");
      expect(stdout).toContain("age: number;");
      expect(stdout).toContain("email: string;");
      // The interests field has min/max constraints so it's generated as a union of tuples
      expect(stdout).toContain("interests?:");
      expect(stdout).toContain("isVip?: boolean;");
      expect(stdout).toContain("preferences?: {");
      expect(stdout).toContain('theme: "light" | "dark" | "auto";');
      expect(stdout).toContain("notifications?: boolean;");
      expect(stdout).toContain("metadata?: {");

      // Check DataAnalysis interface
      expect(stdout).toContain("dataset: string;");
      expect(stdout).toContain('analysisType: "trend" | "correlation" | "summary" | "forecast";');
      expect(stdout).toContain("timeframe?: string;");

      // Check output interfaces
      expect(stdout).toContain("type UserGreetingOut = string");
      expect(stdout).toContain("type SimplePromptOut = string");

      // Check that the main AgentmarkTypes interface is present
      expect(stdout).toContain("export default interface AgentmarkTypes");
      expect(stdout).toContain('"user-greeting.prompt.mdx": UserGreeting');
      expect(stdout).toContain('"data-analysis.prompt.mdx": DataAnalysis');
      expect(stdout).toContain('"simple-prompt.prompt.mdx": SimplePrompt');
    });

    it("should handle prompts without input schemas gracefully", async () => {
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${fixturesDir}`
      );

      // Simple prompt should have empty input interface
      expect(stdout).toContain("interface SimplePromptIn { [key: string]: any }");
    });

    it("should generate proper object prompt types", async () => {
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${fixturesDir}`
      );

      // Check object prompt output type
      expect(stdout).toContain("interface DataAnalysisOut");
      expect(stdout).toContain("summary: string;");
      expect(stdout).toContain("insights: {");
      expect(stdout).toContain("insight: string;");
      expect(stdout).toContain("confidence: number;");
      expect(stdout).toContain("recommendations: string[];");

      // Check that it's marked as object kind (using single quotes)
      expect(stdout).toContain("kind: 'object';");
    });
  });

  describe("JSDoc generation", () => {
    it("should generate JSDoc file when --generate-jsdoc flag is used", async () => {
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`
      );

      // Check that JSDoc file was created
      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      expect(await fs.pathExists(jsdocFile)).toBe(true);

      // Read and verify JSDoc content
      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");

      // Check header comment
      expect(jsdocContent).toContain("Auto-generated JSDoc typedefs from AgentMark .prompt.mdx files");
      expect(jsdocContent).toContain("@fileoverview AgentMark JSDoc Type Definitions");
      expect(jsdocContent).toContain("@generated Do not edit this file directly");

      // JSDoc should be generated but empty since temp dir is initially empty
      expect(jsdocContent).toContain("/**");
    });

    it("should generate proper JSDoc typedefs for prompts with schemas", async () => {
      // Copy fixtures to temp directory for this test
      await fs.copy(fixturesDir, tempDir);

      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`
      );

      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");

      // Check UserGreeting JSDoc
      expect(jsdocContent).toContain("@typedef {object} UserGreetingProps");
      expect(jsdocContent).toContain("@property {string} userName - The user's full name");
      expect(jsdocContent).toContain("@property {integer} age - The user's age in years");
      expect(jsdocContent).toContain("@property {string} email - User's email address");
      expect(jsdocContent).toContain("@property {array} [interests] - List of user interests and hobbies");
      expect(jsdocContent).toContain("@property {boolean} [isVip] - Whether the user is a VIP member");

      // Check DataAnalysis JSDoc
      expect(jsdocContent).toContain("@typedef {object} DataAnalysisProps");
      expect(jsdocContent).toContain("@property {string} dataset - Raw dataset to analyze");
      expect(jsdocContent).toContain('@property {"trend"|"correlation"|"summary"|"forecast"} analysisType - Type of analysis to perform');
      expect(jsdocContent).toContain("@property {string} [timeframe] - Time period for the analysis");

      // Check SimplePrompt JSDoc (no schema)
      expect(jsdocContent).toContain("@typedef {object} SimplePromptProps");
      expect(jsdocContent).toContain("@property {*} [props] - Any props (no schema defined)");

      // Check summary typedef
      expect(jsdocContent).toContain("@typedef {object} AgentMarkPromptTypes");
      expect(jsdocContent).toContain('@property {UserGreetingProps} "user-greeting.prompt.mdx"');
      expect(jsdocContent).toContain('@property {DataAnalysisProps} "data-analysis.prompt.mdx"');
      expect(jsdocContent).toContain('@property {SimplePromptProps} "simple-prompt.prompt.mdx"');
    });

    it("should handle complex nested object schemas in JSDoc", async () => {
      // Copy fixtures to temp directory for this test
      await fs.copy(fixturesDir, tempDir);

      await execAsync(`node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`);

      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");

      // Check that nested object (preferences) is properly handled
      expect(jsdocContent).toContain("@property {object} [preferences] - User preferences configuration");
      
      // Check that metadata (additionalProperties: true) is handled
      expect(jsdocContent).toContain("@property {object} [metadata] - Additional user metadata");
    });

    it("should work alongside TypeScript generation", async () => {
      // Copy fixtures to temp directory for this test
      await fs.copy(fixturesDir, tempDir);

      const { stdout, stderr } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`
      );

      // Both TypeScript and JSDoc should be generated
      expect(stdout).toContain("interface UserGreetingIn");
      expect(stdout).toContain("export default interface AgentmarkTypes");

      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      expect(await fs.pathExists(jsdocFile)).toBe(true);

      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");
      expect(jsdocContent).toContain("@typedef {object} UserGreetingProps");

      // Verify that console output mentions both (these are written to stderr)
      expect(stderr).toContain("Generating type definitions...");
      expect(stderr).toContain("Generating JSDoc documentation...");
      expect(stderr).toContain("JSDoc written to:");
    });
  });

  describe("Error handling", () => {
    it("should handle invalid JSON schemas gracefully", async () => {
      // Create a prompt with invalid schema
      const invalidSchemaPrompt = `---
name: invalid-schema
input_schema:
  type: "invalid-type-that-does-not-exist"
  properties:
    badProp: { type: "also-invalid" }
---

<s>System</s>
<User>Test</User>`;

      const invalidFile = path.join(tempDir, "invalid.prompt.mdx");
      await fs.writeFile(invalidFile, invalidSchemaPrompt);

      // Should not throw, but handle gracefully
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`
      );

      // Should still generate output
      expect(stdout).toBeDefined();

      // JSDoc should still be created with fallback
      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      if (await fs.pathExists(jsdocFile)) {
        const jsdocContent = await fs.readFile(jsdocFile, "utf-8");
        // Should have fallback JSDoc
        expect(jsdocContent).toContain("@typedef {object}");
      }
    });

    it("should handle empty directory gracefully", async () => {
      const { stdout } = await execAsync(
        `node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`
      );

      // Should generate empty but valid output
      expect(stdout).toContain("export default interface AgentmarkTypes");
      
      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      expect(await fs.pathExists(jsdocFile)).toBe(true);
      
      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");
      expect(jsdocContent).toContain("Auto-generated JSDoc typedefs");
    });

    it("should validate root directory exists", async () => {
      const nonExistentDir = path.join(tempDir, "does-not-exist");
      
      try {
        await execAsync(`node ${cliPath} generate-types --root-dir ${nonExistentDir}`);
        expect.fail("Should have thrown an error for non-existent directory");
      } catch (error: any) {
        expect(error.code).toBeGreaterThan(0);
      }
    });
  });

  describe("Integration with json-schema-to-jsdoc package", () => {
    it("should properly use json-schema-to-jsdoc package features", async () => {
      // Copy fixtures to temp directory for this test
      await fs.copy(fixturesDir, tempDir);

      await execAsync(`node ${cliPath} generate-types --root-dir ${tempDir} --generate-jsdoc`);

      const jsdocFile = path.join(tempDir, "agentmark.jsdoc.js");
      const jsdocContent = await fs.readFile(jsdocFile, "utf-8");

      // Check that proper JSDoc @typedef format is used (not function exports)
      expect(jsdocContent).toContain("@typedef {object}");
      expect(jsdocContent).toContain("@property {");
      
      // Should NOT contain function exports (old manual implementation)
      expect(jsdocContent).not.toContain("export function");
      expect(jsdocContent).not.toContain("return props;");

      // Should properly handle enum types
      expect(jsdocContent).toMatch(/@property \{[^}]*\} analysisType.*Type of analysis to perform/);

      // Should properly handle optional properties with [brackets]
      expect(jsdocContent).toContain("[interests]");
      expect(jsdocContent).toContain("[isVip]");
      expect(jsdocContent).toContain("[timeframe]");
    });
  });
});