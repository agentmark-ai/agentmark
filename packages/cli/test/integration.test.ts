import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as os from 'os';

// Mock generateTypes function for integration testing
async function testGenerateJSDocFromFiles(rootDir: string): Promise<string> {
  // This simulates the generate-types command for JSDoc
  const files = await fs.readdir(rootDir);
  const promptFiles = files.filter(file => file.endsWith('.prompt.mdx'));
  
  const prompts = [];
  for (const file of promptFiles) {
    const filePath = path.join(rootDir, file);
    const content = await fs.readFile(filePath, 'utf-8');
    
    // Simple frontmatter extraction (in real code this uses front-matter library)
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      try {
        const yaml = require('yaml');
        const frontmatter = yaml.parse(frontmatterMatch[1]);
        prompts.push({
          path: file,
          input_schema: frontmatter.input_schema,
          ...frontmatter
        });
      } catch (error) {
        console.warn(`Failed to parse frontmatter for ${file}:`, error);
      }
    }
  }

  // Generate JSDoc (simplified version of the actual function)
  const jsdoc = require('json-schema-to-jsdoc');
  
  function getInterfaceName(filePath: string): string {
    return filePath
      .replace(/\.prompt\.mdx$/, "")
      .split("/")
      .map((part) => {
        return part
          .split(/[-_]|(?=[A-Z])/)
          .map(
            (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
          )
          .join("")
          .replace(/[^a-zA-Z0-9]/g, "");
      })
      .join("$");
  }

  function convertJsonSchemaToJSDoc(schema: any, typeName: string): string {
    if (!schema) {
      return `/**
 * @typedef {Object} ${typeName}
 */`;
    }

    const schemaWithTitle = {
      ...schema,
      title: typeName
    };

    return jsdoc(schemaWithTitle, {
      hyphenatedDescriptions: true,
      capitalizeTitle: false
    });
  }

  const headerComment = `/**
 * Auto-generated JSDoc definitions from AgentMark
 * Do not edit this file directly
 * 
 * Import this file in your .prompt.mdx files for type safety:
 * {/** @import {MyPromptProps} from './agentmark.jsdoc.js' */}
 */

`;

  let jsDocDefinitions: string[] = [];

  for (const prompt of prompts) {
    const { path: promptPath, input_schema } = prompt;
    const name = getInterfaceName(promptPath);
    const typeName = `${name}Props`;
    
    if (input_schema) {
      const jsDoc = convertJsonSchemaToJSDoc(input_schema, typeName);
      jsDocDefinitions.push(jsDoc);
    } else {
      const genericJSDoc = `/**
 * @typedef {Object} ${typeName}
 * @property {any} [key] - Generic props object for ${promptPath}
 */`;
      jsDocDefinitions.push(genericJSDoc);
    }
  }

  const availableTypes = prompts.map(prompt => {
    const name = getInterfaceName(prompt.path);
    return ` * - ${name}Props: Props for ${prompt.path}`;
  }).join('\n');

  const summaryComment = `
/**
 * Available JSDoc types for AgentMark prompts:
${availableTypes}
 * 
 * Usage in .prompt.mdx files:
 * {/** @import {PromptNameProps} from './agentmark.jsdoc.js' */}
 * {/** @param {PromptNameProps} props */}
 */`;

  return headerComment + jsDocDefinitions.join('\n\n') + '\n' + summaryComment;
}

describe('JSDoc Generation Integration Tests', () => {
  let tempDir: string;

  beforeEach(async () => {
    // Create a temporary directory for test files
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'agentmark-test-'));
  });

  afterEach(async () => {
    // Clean up temporary directory
    await fs.remove(tempDir);
  });

  it('should generate JSDoc from real .prompt.mdx files', async () => {
    // Create test .prompt.mdx files
    const customerSupportPrompt = `---
name: customer-support
text_config:
  model_name: gpt-4o
  temperature: 0.3
input_schema:
  type: object
  properties:
    customer_question:
      type: string
      description: "The customer's question or concern"
    priority:
      type: string
      description: "Priority level: low, medium, high"
    customer_id:
      type: string
      description: "Unique identifier for the customer"
  required:
    - customer_question
---

<s>
You are a helpful customer support assistant.
</s>

<User>
Customer ID: {props.customer_id}
Priority: {props.priority || "medium"}

Customer Question: {props.customer_question}
</User>`;

    const mathPrompt = `---
name: math
text_config:
  model_name: gpt-4o
input_schema:
  type: object
  properties:
    userMessage:
      type: string
      description: "The math problem to solve"
  required:
    - userMessage
---

<s>
You are a helpful math tutor.
</s>

<User>
{props.userMessage}
</User>`;

    const imagePrompt = `---
name: image-generation
image_config:
  model_name: dall-e-3
  size: 1024x1024
input_schema:
  type: object
  properties:
    prompt:
      type: string
      description: "Description of the image to generate"
    style:
      type: string
      description: "Art style for the image"
    negative_prompt:
      type: string
      description: "What to avoid in the image"
  required:
    - prompt
---

<ImagePrompt>
{props.prompt}
{props.style && \`Style: \${props.style}\`}
{props.negative_prompt && \`Avoid: \${props.negative_prompt}\`}
</ImagePrompt>`;

    // Write test files
    await fs.writeFile(path.join(tempDir, 'customer-support.prompt.mdx'), customerSupportPrompt);
    await fs.writeFile(path.join(tempDir, 'math.prompt.mdx'), mathPrompt);
    await fs.writeFile(path.join(tempDir, 'image-generation.prompt.mdx'), imagePrompt);

    // Generate JSDoc
    const result = await testGenerateJSDocFromFiles(tempDir);

    // Verify the generated JSDoc contains expected content
    expect(result).toContain('Auto-generated JSDoc definitions from AgentMark');
    expect(result).toContain('Do not edit this file directly');

    // Check that all three prompt types are included
    expect(result).toContain('@typedef {object} CustomerSupportProps');
    expect(result).toContain('@typedef {object} MathProps'); 
    expect(result).toContain('@typedef {object} ImageGenerationProps');

    // Check specific properties are correctly generated
    expect(result).toContain('@property {string} customer_question - The customer\'s question or concern');
    expect(result).toContain('@property {string} [priority] - Priority level: low, medium, high');
    expect(result).toContain('@property {string} [customer_id] - Unique identifier for the customer');
    
    expect(result).toContain('@property {string} userMessage - The math problem to solve');
    
    expect(result).toContain('@property {string} prompt - Description of the image to generate');
    expect(result).toContain('@property {string} [style] - Art style for the image');
    expect(result).toContain('@property {string} [negative_prompt] - What to avoid in the image');

    // Check summary includes all prompts
    expect(result).toContain('CustomerSupportProps: Props for customer-support.prompt.mdx');
    expect(result).toContain('MathProps: Props for math.prompt.mdx');
    expect(result).toContain('ImageGenerationProps: Props for image-generation.prompt.mdx');

    // Check usage instructions
    expect(result).toContain('Usage in .prompt.mdx files:');
    expect(result).toContain('{/** @import {PromptNameProps} from \'./agentmark.jsdoc.js\' */}');
    expect(result).toContain('{/** @param {PromptNameProps} props */}');
  });

  it('should handle prompts without input_schema', async () => {
    const simplePrompt = `---
name: simple
text_config:
  model_name: gpt-4o
---

<s>
You are a helpful assistant.
</s>

<User>
Hello!
</User>`;

    await fs.writeFile(path.join(tempDir, 'simple.prompt.mdx'), simplePrompt);

    const result = await testGenerateJSDocFromFiles(tempDir);

    expect(result).toContain('@typedef {Object} SimpleProps');
    expect(result).toContain('Generic props object for simple.prompt.mdx');
  });

  it('should handle complex nested schemas', async () => {
    const complexPrompt = `---
name: complex
text_config:
  model_name: gpt-4o
input_schema:
  type: object
  properties:
    user:
      type: object
      properties:
        name:
          type: string
          description: "User's full name"
        age:
          type: integer
          description: "User's age"
        preferences:
          type: array
          items:
            type: string
          description: "List of user preferences"
      required:
        - name
      description: "User information"
    settings:
      type: object
      description: "Application settings"
    tags:
      type: array
      items:
        type: string
      description: "Content tags"
  required:
    - user
---

<User>
Process user data: {JSON.stringify(props.user)}
</User>`;

    await fs.writeFile(path.join(tempDir, 'complex.prompt.mdx'), complexPrompt);

    const result = await testGenerateJSDocFromFiles(tempDir);

    expect(result).toContain('@typedef {object} ComplexProps');
    expect(result).toContain('user');
    expect(result).toContain('settings');
    expect(result).toContain('tags');
  });

  it('should validate generated JSDoc format', async () => {
    const testPrompt = `---
name: validation-test
text_config:
  model_name: gpt-4o
input_schema:
  type: object
  properties:
    stringProp:
      type: string
      description: "A string property"
    numberProp:
      type: number
      description: "A number property"
    booleanProp:
      type: boolean
      description: "A boolean property"
    arrayProp:
      type: array
      items:
        type: string
      description: "An array property"
    objectProp:
      type: object
      description: "An object property"
  required:
    - stringProp
    - numberProp
---

<User>
Test: {props.stringProp}
</User>`;

    await fs.writeFile(path.join(tempDir, 'validation-test.prompt.mdx'), testPrompt);

    const result = await testGenerateJSDocFromFiles(tempDir);

    // Verify the JSDoc follows proper format
    expect(result).toMatch(/\/\*\*[\s\S]*?\*\//); // Contains JSDoc comments
    expect(result).toContain('@typedef {object} ValidationTestProps');
    
         // Verify all property types are correctly mapped
     expect(result).toContain('@property {string} stringProp - A string property');
     expect(result).toContain('@property {number} numberProp - A number property'); // numberProp is required in our test schema
     expect(result).toContain('@property {boolean} [booleanProp] - A boolean property');
    expect(result).toContain('arrayProp'); // Array handling depends on json-schema-to-jsdoc
    expect(result).toContain('objectProp');

         // Verify required vs optional properties are distinguished
     // From the schema: stringProp and numberProp are both required
     expect(result).toContain('@property {string} stringProp'); // Required
     expect(result).toContain('@property {number} numberProp'); // Also required in our test schema
  });

  it('should handle file naming edge cases', async () => {
    // Test various file naming patterns (only root level files for simplicity)
    const fileNames = [
      'simple-name.prompt.mdx',
      'camelCaseName.prompt.mdx', 
      'snake_case_name.prompt.mdx',
      'file-with-numbers123.prompt.mdx'
    ];

    for (const fileName of fileNames) {
      await fs.writeFile(path.join(tempDir, fileName), `---
name: test
text_config:
  model_name: gpt-4o
input_schema:
  type: object
  properties:
    test:
      type: string
  required:
    - test
---

<User>Test</User>`);
    }

    const result = await testGenerateJSDocFromFiles(tempDir);

    // Each file should generate a typedef
    expect(result).toContain('@typedef {object} SimpleNameProps');
    expect(result).toContain('@typedef {object} CamelCaseNameProps');
    expect(result).toContain('@typedef {object} SnakeCaseNameProps');
    expect(result).toContain('@typedef {object} FileWithNumbers123Props');
  });
});