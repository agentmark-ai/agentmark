import * as fs from "fs-extra";
import path from "path";
import fm from "front-matter";
import { compile } from "json-schema-to-typescript";

type Options = {
  language: "typescript";
  local?: number;
  rootDir?: string;
};

type PromptFrontmatter = {
  path: string;
  model?: {
    settings?: {
      schema?: any;
    };
  };
  input_schema?: any;
};

function getInterfaceName(filePath: string): string {
  return filePath
    .replace(/\.prompt\.mdx$/, "")
    .split("/")
    .map(
      (part) =>
        part.charAt(0).toUpperCase() +
        part.slice(1).replace(/[^a-zA-Z0-9]/g, "")
    )
    .join("$");
}

export async function findPromptFiles(dir: string): Promise<string[]> {
  const files = await fs.readdir(dir, { withFileTypes: true });
  let promptFiles: string[] = [];

  for (const file of files) {
    const fullPath = path.join(dir, file.name);
    if (file.isDirectory()) {
      promptFiles = promptFiles.concat(await findPromptFiles(fullPath));
    } else if (file.name.endsWith(".prompt.mdx")) {
      promptFiles.push(fullPath);
    }
  }

  return promptFiles;
}

async function generateTypeDefinitions(
  prompts: PromptFrontmatter[]
): Promise<string> {
  let interfaces: string[] = [];
  const headerComment = `// Auto-generated types from Agentmark
// Do not edit this file directly

`;
  let output = "";
  let typeMapping: string[] = [];

  for (const prompt of prompts) {
    const { path: promptPath, input_schema, model } = prompt;
    console.log(prompt);
    const name = getInterfaceName(promptPath);

    try {
      const inputInterface = input_schema
        ? await compile(input_schema, `${name}In`, {
            bannerComment: "",
            additionalProperties: false,
          })
        : `interface ${name}In { [key: string]: any }`;

      const outputSchema = model?.settings?.schema;

      console.log(outputSchema);

      const outputInterface = outputSchema
        ? await compile(outputSchema, `${name}Out`, {
            bannerComment: "",
            additionalProperties: false,
          })
        : `type ${name}Out = string`;

      interfaces.push(
        inputInterface.replace("export interface", "interface"),
        outputInterface
          .replace("export type", "type")
          .replace("export interface", "interface")
      );

      output += `interface ${name} {
  input: ${name}In;
  output: ${name}Out;
}\n\n`;

      typeMapping.push(`  "${promptPath}": ${name}`);
    } catch (error: any) {
      console.error(`Error processing ${promptPath}:`, error);
      interfaces.push(
        `interface ${name}In { [key: string]: any }
type ${name}Out = string`
      );

      output += `interface ${name} {
  input: ${name}In;
  output: ${name}Out;
}\n\n`;

      typeMapping.push(`  "${promptPath}": ${name}`);
    }
  }

  output += `export default interface AgentmarkTypes {
${typeMapping.join(",\n")}
}\n`;

  return headerComment + interfaces.join("\n\n") + "\n\n" + output;
}

async function fetchPromptsFrontmatter(options: {
  local?: number;
  rootDir?: string;
}): Promise<PromptFrontmatter[]> {
  if (options.local) {
    const baseUrl = `http://localhost:${options.local}`;
    try {
      const pathsResponse = await fetch(`${baseUrl}/v1/prompts`);
      if (!pathsResponse.ok) {
        throw new Error(
          `Failed to fetch prompt paths: ${pathsResponse.statusText}`
        );
      }

      const { paths } = await pathsResponse.json();

      return Promise.all(
        paths.map(async (promptPath: string) => {
          const templateResponse = await fetch(
            `${baseUrl}/v1/templates?path=${promptPath}`
          );
          if (!templateResponse.ok) {
            throw new Error(
              `Failed to fetch template ${promptPath}: ${templateResponse.statusText}`
            );
          }

          const { data: ast } = await templateResponse.json();
          const yamlNode = ast.children.find(
            (node: any) => node.type === "yaml"
          );
          if (!yamlNode) {
            throw new Error(`No YAML frontmatter found in ${promptPath}`);
          }

          const { parse: parseYaml } = await import("yaml");
          const frontmatter = parseYaml(yamlNode.value);

          return {
            path: promptPath,
            model: frontmatter.model || {},
            input_schema: frontmatter.input_schema,
          };
        })
      );
    } catch (error) {
      if (
        error instanceof TypeError &&
        error.message.includes("fetch failed")
      ) {
        console.error(`Connection failed to ${baseUrl}.`);
      }
      console.error("\nError details:", error);
      process.exit(1);
    }
  }

  if (options.rootDir) {
    if (!fs.existsSync(options.rootDir)) {
      throw new Error(`Directory not found at: ${options.rootDir}`);
    }

    const promptFiles = await findPromptFiles(options.rootDir);

    return Promise.all(
      promptFiles.map(async (file) => {
        const content = await fs.readFile(file, "utf-8");
        const { attributes } = fm<any>(content);
        return {
          path: path.relative(options.rootDir!, file),
          model: attributes.model || {},
          input_schema: attributes.input_schema,
        };
      })
    );
  }

  throw new Error("Either --local or --root-dir must be specified");
}

const generateTypes = async ({ language, local }: Options) => {
  if (language !== "typescript") {
    console.error(
      `Unsupported language: ${language}. Only TypeScript is supported.`
    );
    return;
  }

  try {
    console.error("Generating type definitions...");
    const prompts = await fetchPromptsFrontmatter({ local });

    const typeDefinitions = await generateTypeDefinitions(prompts);

    process.stdout.write(typeDefinitions);
    console.error("Done");
  } catch (error) {
    console.error("Error generating types:", error);
    process.exit(1);
  }
};

export default generateTypes;
