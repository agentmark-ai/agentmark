import { spawn } from "child_process";
import path from "path";
import fs from "fs";
import { createFileServer } from "../file-server";

function getSafeCwd(): string {
  try { return process.cwd(); } catch { return process.env.PWD || process.env.INIT_CWD || '.'; }
}

const dev = async (options: { port?: number; runnerPort?: number } = {}) => {
  const fileServerPort = options.port || 9418;
  const runnerPort = options.runnerPort || 9417;
  const cwd = getSafeCwd();

  // Check if agentmark.client.ts exists
  const configPath = path.join(cwd, 'agentmark.client.ts');
  if (!fs.existsSync(configPath)) {
    console.error('Error: agentmark.client.ts not found in current directory');
    console.error('Run this command from your AgentMark project root');
    process.exit(1);
  }


  // Determine which dev server entry point to use
  const customDevServer = path.join(cwd, 'dev-server.ts');
  const autoGeneratedEntry = path.join(cwd, '.agentmark', 'dev-entry.ts');

  let devServerFile: string;

  if (fs.existsSync(customDevServer)) {
    console.log('Using custom dev-server.ts');
    devServerFile = customDevServer;
  } else if (fs.existsSync(autoGeneratedEntry)) {
    devServerFile = autoGeneratedEntry;
  } else {
    console.error('Error: No dev server entry point found.');
    console.error('Expected .agentmark/dev-entry.ts to be created during initialization.');
    console.error('Please run "npx create-agentmark" to set up a new project.');
    process.exit(1);
  }

  // Start file server directly
  let fileServerInstance: any;
  try {
    fileServerInstance = await createFileServer(fileServerPort);
  } catch (error: any) {
    console.error('Failed to start file server:', error.message);
    process.exit(1);
  }

  const killProcessTree = (pid: number) => {
    try {
      // Kill all children first
      try {
        spawn('pkill', ['-P', String(pid)], { stdio: 'ignore' });
      } catch {}
      // Then kill the main process
      process.kill(pid, 'SIGKILL');
    } catch (e) {
      // Ignore errors (process may already be dead)
    }
  };

  // Start runner server
  const runnerServer = spawn('npx', ['tsx', '--watch', devServerFile, 'agentmark.client.ts', 'agentmark/**/*', `--runner-port=${runnerPort}`, `--file-server-port=${fileServerPort}`], {
    stdio: 'inherit',
    cwd
  });

  runnerServer.on('error', (error) => {
    console.error('Failed to start runner server:', error.message);
    if (fileServerInstance) {
      try { fileServerInstance.close(); } catch {}
    }
    process.exit(1);
  });

  runnerServer.on('exit', (code) => {
    console.log(`\nRunner server exited with code ${code}`);
    if (fileServerInstance) {
      try { fileServerInstance.close(); } catch {}
    }
    process.exit(code || 0);
  });

  // Give servers time to start, then print summary
  setTimeout(() => {
    console.log('\n' + '‚ïê'.repeat(70));
    console.log('üöÄ AgentMark Development Servers Running');
    console.log('‚ïê'.repeat(70));
    console.log(`\n  File Server:   http://localhost:${fileServerPort}`);
    console.log(`  Runner Server: http://localhost:${runnerPort}`);
    console.log('\n' + '‚îÄ'.repeat(70));
    console.log('How to run prompts and experiments:');
    console.log('‚îÄ'.repeat(70));
    console.log('\n  Open a new terminal window and run:');
    console.log('\n  Run a prompt:');
    console.log('  $ npm run prompt agentmark/<file>.prompt.mdx');
    console.log('\n  Run an experiment:');
    console.log('  $ npm run experiment agentmark/<file>.prompt.mdx');
    console.log('\n' + '‚ïê'.repeat(70));
    console.log('Press Ctrl+C in this terminal to stop the servers');
    console.log('‚ïê'.repeat(70) + '\n');
  }, 3000);

  // Handle process termination
  let isShuttingDown = false;
  const cleanup = () => {
    if (isShuttingDown) return;
    isShuttingDown = true;

    console.log('\nShutting down servers...');

    if (fileServerInstance) {
      try { fileServerInstance.close(); } catch {}
    }
    if (runnerServer.pid) killProcessTree(runnerServer.pid);

    setTimeout(() => process.exit(0), 500);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('exit', cleanup);
};

export default dev;
