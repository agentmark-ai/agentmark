import { spawn } from "child_process";
import path from "path";
import fs from "fs";
import { createFileServer } from "../file-server";
import { createTunnel, type TunnelInfo } from "../tunnel";
import { loadLocalConfig, getTunnelSubdomain } from "../config";
import type { LocalConfig } from "../config";

function getSafeCwd(): string {
  try { return process.cwd(); } catch { return process.env.PWD || process.env.INIT_CWD || '.'; }
}

function getConfigDaysRemaining(config: LocalConfig): number {
  if (!config.createdAt) return 30;
  const createdDate = new Date(config.createdAt);
  const daysSinceCreation = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24);
  return Math.ceil(30 - daysSinceCreation);
}

const dev = async (options: { port?: number; webhookPort?: number; tunnel?: boolean } = {}) => {
  const fileServerPort = options.port || 9418;
  const webhookPort = options.webhookPort || 9417;
  const useTunnel = options.tunnel || false;
  const cwd = getSafeCwd();

  // Load or create local config with webhook secret
  const config = loadLocalConfig();

  // Set webhook secret from local config if not already set
  // This is the source of truth for local development
  if (!process.env.AGENTMARK_WEBHOOK_SECRET && config.webhookSecret) {
    process.env.AGENTMARK_WEBHOOK_SECRET = config.webhookSecret;
  }

  // For local-only mode, skip signature verification for convenience
  if (!useTunnel) {
    process.env.AGENTMARK_WEBHOOK_SECRET = '';
  }

  // Check if agentmark.client.ts exists
  const configPath = path.join(cwd, 'agentmark.client.ts');
  if (!fs.existsSync(configPath)) {
    console.error('Error: agentmark.client.ts not found in current directory');
    console.error('Run this command from your AgentMark project root');
    process.exit(1);
  }


  // Determine which dev server entry point to use
  const customDevServer = path.join(cwd, 'dev-server.ts');
  const autoGeneratedEntry = path.join(cwd, '.agentmark', 'dev-entry.ts');

  let devServerFile: string;

  if (fs.existsSync(customDevServer)) {
    console.log('Using custom dev-server.ts');
    devServerFile = customDevServer;
  } else if (fs.existsSync(autoGeneratedEntry)) {
    devServerFile = autoGeneratedEntry;
  } else {
    console.error('Error: No dev server entry point found.');
    console.error('Expected .agentmark/dev-entry.ts to be created during initialization.');
    console.error('Please run "npx create-agentmark" to set up a new project.');
    process.exit(1);
  }

  // Start file server directly
  let fileServerInstance: any;
  try {
    fileServerInstance = await createFileServer(fileServerPort);
    // Don't print file server URL here, will be printed in the summary below
  } catch (error: any) {
    console.error('Failed to start file server:', error.message);
    process.exit(1);
  }

  const killProcessTree = (pid: number) => {
    try {
      // Kill all child processes first
      try {
        const result = spawn('pkill', ['-TERM', '-P', String(pid)], { stdio: 'pipe' });
        result.on('close', () => {
          // After children are killed, kill the parent
          try {
            process.kill(pid, 'SIGTERM');
          } catch {}
          // Force kill after delay if still alive
          setTimeout(() => {
            try {
              process.kill(pid, 'SIGKILL');
            } catch {}
          }, 200);
        });
      } catch {
        // If pkill fails, just kill the parent process
        try {
          process.kill(pid, 'SIGTERM');
          setTimeout(() => {
            try {
              process.kill(pid, 'SIGKILL');
            } catch {}
          }, 200);
        } catch {}
      }
    } catch (e) {
      // Ignore errors (process may already be dead)
    }
  };

  // Start webhook server using local tsx installation
  // Find tsx binary - will be in node_modules/.bin/tsx
  const tsxPath = path.join(require.resolve('tsx'), '../../dist/cli.mjs');
  const webhookServer = spawn(process.execPath, [tsxPath, '--watch', devServerFile, 'agentmark.client.ts', 'agentmark/**/*', `--webhook-port=${webhookPort}`, `--file-server-port=${fileServerPort}`], {
    stdio: 'inherit',
    cwd
  });

  webhookServer.on('error', (error) => {
    console.error('Failed to start webhook server:', error.message);
    if (fileServerInstance) {
      try { fileServerInstance.close(); } catch {}
    }
    process.exit(1);
  });

  webhookServer.on('exit', (code) => {
    if (code === 0 || code === null) {
      console.log('\nWebhook server stopped');
    } else {
      console.error(`\n‚ùå Webhook server exited with error code ${code}`);
      console.error('Check the output above for error details');
    }
    if (fileServerInstance) {
      try { fileServerInstance.close(); } catch {}
    }
    process.exit(code || 0);
  });

  // Store tunnel info for cleanup
  let tunnelInfo: TunnelInfo | null = null;

  // Give servers time to start, then print summary and optionally setup tunnel
  setTimeout(async () => {
    // Verify webhook server is still running before showing success message
    if (webhookServer.exitCode !== null) {
      console.error('\n‚ùå Webhook server failed to start');
      console.error('The file server is running, but the webhook server did not start successfully');
      return;
    }

    // Setup tunnel if requested
    if (useTunnel) {
      try {
        const subdomain = getTunnelSubdomain();
        tunnelInfo = await createTunnel(webhookPort, subdomain);
      } catch (error) {
        console.error('Continuing without tunnel...\n');
      }
    }

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('üöÄ AgentMark Development Server');
    console.log('‚ïê'.repeat(70));

    console.log(`\n  Webhook: http://localhost:${webhookPort}`);
    console.log(`  Files:   http://localhost:${fileServerPort}`);

    if (useTunnel && tunnelInfo) {
      console.log(`  Public:  ${tunnelInfo.url}`);
      console.log(`\n  Secret:  ${config.webhookSecret}`);
      console.log(`  Valid:   ${getConfigDaysRemaining(config)} days remaining`);
    }

    console.log('\n  Run a prompt:     npm run prompt agentmark/<file>.prompt.mdx');
    console.log('  Run an experiment: npm run experiment agentmark/<file>.prompt.mdx');

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('Press Ctrl+C to stop');
    console.log('‚ïê'.repeat(70) + '\n');
  }, 3000);

  // Handle process termination
  let isShuttingDown = false;
  const cleanup = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;

    console.log('\nShutting down servers...');

    // Close tunnel first
    if (tunnelInfo) {
      try {
        console.log('  Closing tunnel...');
        await tunnelInfo.disconnect();
      } catch (error) {
        console.error('  Error disconnecting tunnel:', error);
      }
    }

    // Close file server with force close on all connections
    if (fileServerInstance) {
      try {
        console.log('  Stopping file server...');
        // Force close all connections
        await new Promise<void>((resolve) => {
          fileServerInstance.closeAllConnections?.();
          fileServerInstance.close(() => {
            resolve();
          });
          // Timeout in case close hangs
          setTimeout(resolve, 1000);
        });
      } catch (error) {
        console.error('  Error stopping file server:', error);
      }
    }

    // Kill webhook server process tree
    if (webhookServer.pid) {
      console.log('  Stopping webhook server...');
      killProcessTree(webhookServer.pid);
    }

    console.log('Servers stopped.');

    // Give processes time to die, then force exit
    // Increased timeout to allow for graceful shutdown
    setTimeout(() => {
      process.exit(0);
    }, 1000);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);

  // Don't use exit handler - it causes issues with async cleanup
  // The SIGINT/SIGTERM handlers will trigger process.exit()
};

export default dev;
