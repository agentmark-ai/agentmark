import path from "path";
import * as fs from "fs-extra";
import modelsData from "@agentmark-ai/model-registry/models.json";
import overridesData from "@agentmark-ai/model-registry/overrides.json";

const allRegistryModels: Record<string, { provider: string; mode: string }> = {
  ...(modelsData as any).models,
  ...(overridesData as any).models,
};

type Options = {
  outDir?: string;
};

function classifyModels(builtInModels: string[]): {
  languageModels: string[];
  imageModels: string[];
  speechModels: string[];
  unknownModels: string[];
} {
  const languageModels: string[] = [];
  const imageModels: string[] = [];
  const speechModels: string[] = [];
  const unknownModels: string[] = [];

  for (const prefixedId of builtInModels) {
    const slashIndex = prefixedId.indexOf("/");
    if (slashIndex === -1) {
      unknownModels.push(prefixedId);
      continue;
    }
    const modelId = prefixedId.slice(slashIndex + 1);
    const entry = allRegistryModels[modelId];

    if (!entry) {
      unknownModels.push(prefixedId);
      continue;
    }

    switch (entry.mode) {
      case "chat":
        languageModels.push(prefixedId);
        break;
      case "image_generation":
        imageModels.push(prefixedId);
        break;
      case "audio_speech":
        speechModels.push(prefixedId);
        break;
      default:
        unknownModels.push(prefixedId);
    }
  }

  return { languageModels, imageModels, speechModels, unknownModels };
}

function buildModelNameSchema(models: string[], fallback: string[]): Record<string, unknown> {
  const enum_ = [...models, ...fallback];
  return enum_.length > 0
    ? {
        type: "string",
        enum: enum_,
        description: `Model name from builtInModels in agentmark.json. Run 'agentmark pull-models' to add models.`,
      }
    : {
        type: "string",
        description: `Model name. Run 'agentmark pull-models' to populate builtInModels in agentmark.json and regenerate this schema for IDE autocomplete.`,
      };
}

const generateSchema = async ({ outDir }: Options = {}) => {
  let agentmarkConfig: Record<string, unknown> | null = null;

  try {
    agentmarkConfig = await fs.readJSON(
      path.join(process.cwd(), "agentmark.json")
    );
  } catch (_error) {
    throw new Error(
      "Agentmark project not found. Please initialize first using agentmark init."
    );
  }

  const builtInModels: string[] = Array.isArray(agentmarkConfig?.["builtInModels"])
    ? (agentmarkConfig!["builtInModels"] as string[])
    : [];

  const { languageModels, imageModels, speechModels, unknownModels } = classifyModels(builtInModels);

  // Unknown models (not in registry) are included in all sections as a safe fallback.
  const languageSchema = buildModelNameSchema(languageModels, unknownModels);
  const imageSchema = buildModelNameSchema(imageModels, unknownModels);
  const speechSchema = buildModelNameSchema(speechModels, unknownModels);

  const schema: Record<string, unknown> = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "AgentMark Prompt Frontmatter",
    description: "Schema for .prompt.mdx frontmatter YAML validation. Generated by 'agentmark generate-schema'.",
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Prompt name",
      },
      text_config: {
        type: "object",
        description: "Configuration for text/language model prompts",
        properties: {
          model_name: languageSchema,
          max_tokens: { type: "number" },
          temperature: { type: "number", minimum: 0, maximum: 2 },
          max_calls: { type: "number" },
          top_p: { type: "number", minimum: 0, maximum: 1 },
          top_k: { type: "number" },
          presence_penalty: { type: "number" },
          frequency_penalty: { type: "number" },
          stop_sequences: { type: "array", items: { type: "string" } },
          seed: { type: "number" },
          max_retries: { type: "number" },
        },
        required: ["model_name"],
        additionalProperties: false,
      },
      object_config: {
        type: "object",
        description: "Configuration for structured object output prompts",
        properties: {
          model_name: languageSchema,
          max_tokens: { type: "number" },
          temperature: { type: "number", minimum: 0, maximum: 2 },
          max_calls: { type: "number" },
          top_p: { type: "number", minimum: 0, maximum: 1 },
          top_k: { type: "number" },
          presence_penalty: { type: "number" },
          frequency_penalty: { type: "number" },
          stop_sequences: { type: "array", items: { type: "string" } },
          seed: { type: "number" },
          max_retries: { type: "number" },
          schema: { type: "object", description: "JSON Schema for the structured output" },
          schema_name: { type: "string" },
          schema_description: { type: "string" },
        },
        required: ["model_name", "schema"],
        additionalProperties: false,
      },
      image_config: {
        type: "object",
        description: "Configuration for image generation prompts",
        properties: {
          model_name: imageSchema,
          prompt: { type: "string" },
          num_images: { type: "number" },
          size: { type: "string", pattern: "^\\d+x\\d+$" },
          aspect_ratio: { type: "string", pattern: "^\\d+:\\d+$" },
          seed: { type: "number" },
        },
        required: ["model_name"],
        additionalProperties: false,
      },
      speech_config: {
        type: "object",
        description: "Configuration for text-to-speech prompts",
        properties: {
          model_name: speechSchema,
          text: { type: "string" },
          voice: { type: "string" },
          output_format: { type: "string" },
          instructions: { type: "string" },
          speed: { type: "number" },
        },
        required: ["model_name"],
        additionalProperties: false,
      },
      test_settings: {
        type: "object",
        properties: {
          props: {},
          dataset: { type: "string" },
          evals: { type: "array", items: { type: "string" } },
        },
        additionalProperties: false,
      },
    },
    additionalProperties: true,
  };

  const outputDir = outDir
    ? path.resolve(process.cwd(), outDir)
    : path.join(process.cwd(), ".agentmark");

  await fs.ensureDir(outputDir);

  const schemaPath = path.join(outputDir, "prompt.schema.json");
  await fs.writeJSON(schemaPath, schema, { spaces: 2 });

  const relPath = path.relative(process.cwd(), schemaPath);
  console.error(
    `Schema written to ${relPath}` +
      (builtInModels.length > 0
        ? ` (${builtInModels.length} model(s) in enum)`
        : " (no builtInModels found â€” run 'agentmark pull-models' first)")
  );
};

export default generateSchema;
