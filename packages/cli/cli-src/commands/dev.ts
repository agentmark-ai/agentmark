import { spawn } from "child_process";
import path from "path";
import fs from "fs";
import net from "net";
import { createApiServer } from "../api-server";
import { createTunnel, type TunnelInfo } from "../tunnel";
import { loadLocalConfig, getTunnelSubdomain } from "../config";
import type { LocalConfig } from "../config";

function getSafeCwd(): string {
  try { return process.cwd(); } catch { return process.env.PWD || process.env.INIT_CWD || '.'; }
}

function isPortFree(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const tester = net.createServer()
      .once('error', () => resolve(false))
      .once('listening', () => tester.close(() => resolve(true)))
      .listen(port);
  });
}

function getConfigDaysRemaining(config: LocalConfig): number {
  if (!config.createdAt) return 30;
  const createdDate = new Date(config.createdAt);
  const daysSinceCreation = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24);
  return Math.ceil(30 - daysSinceCreation);
}

const dev = async (options: { apiPort?: number; webhookPort?: number; appPort?: number; tunnel?: boolean } = {}) => {
  const apiPort = options.apiPort || 9418;
  const webhookPort = options.webhookPort || 9417;
  const appPort = options.appPort || 3000;
  const useTunnel = options.tunnel || false;
  const cwd = getSafeCwd();

  // Load or create local config with webhook secret
  const config = loadLocalConfig();

  // Set webhook secret from local config if not already set
  // This is the source of truth for local development
  if (!process.env.AGENTMARK_WEBHOOK_SECRET && config.webhookSecret) {
    process.env.AGENTMARK_WEBHOOK_SECRET = config.webhookSecret;
  }

  // For local-only mode, skip signature verification for convenience
  if (!useTunnel) {
    process.env.AGENTMARK_WEBHOOK_SECRET = '';
  }

  // Check if agentmark.client.ts exists
  const configPath = path.join(cwd, 'agentmark.client.ts');
  if (!fs.existsSync(configPath)) {
    console.error('Error: agentmark.client.ts not found in current directory');
    console.error('Run this command from your AgentMark project root');
    process.exit(1);
  }


  // Determine which dev server entry point to use
  const customDevServer = path.join(cwd, 'dev-server.ts');
  const autoGeneratedEntry = path.join(cwd, '.agentmark', 'dev-entry.ts');

  let devServerFile: string;

  if (fs.existsSync(customDevServer)) {
    console.log('Using custom dev-server.ts');
    devServerFile = customDevServer;
  } else if (fs.existsSync(autoGeneratedEntry)) {
    devServerFile = autoGeneratedEntry;
  } else {
    console.error('Error: No dev server entry point found.');
    console.error('Expected .agentmark/dev-entry.ts to be created during initialization.');
    console.error('Please run "npx create-agentmark" to set up a new project.');
    process.exit(1);
  }

  // Start API server directly
  let apiServerInstance: any;
  try {
    console.log(`Starting...`);
    apiServerInstance = await createApiServer(apiPort);
  } catch (error: any) {
    console.error('Failed to start API server:', error.message);
    console.error(error.stack);
    process.exit(1);
  }

  const killProcessTree = (pid: number) => {
    try {
      // Kill all child processes first
      try {
        const result = spawn('pkill', ['-TERM', '-P', String(pid)], { stdio: 'pipe' });
        result.on('close', () => {
          // After children are killed, kill the parent
          try {
            process.kill(pid, 'SIGTERM');
          } catch {
            // Ignore errors (process may already be dead)
          }
          // Force kill after delay if still alive
          setTimeout(() => {
            try {
              process.kill(pid, 'SIGKILL');
            } catch {
              // Ignore errors (process may already be dead)
            }
          }, 200);
        });
      } catch {
        // If pkill fails, just kill the parent process
        try {
          process.kill(pid, 'SIGTERM');
          setTimeout(() => {
            try {
              process.kill(pid, 'SIGKILL');
            } catch {
              // Ignore errors (process may already be dead)
            }
          }, 200);
        } catch {
          // Ignore errors (process may already be dead)
        }
      }
    } catch {
      // Ignore errors (process may already be dead)
    }
  };

  // Track shutdown state to suppress exit messages during intentional shutdown
  let isShuttingDown = false;

  // Start webhook server using local tsx installation
  // Find tsx binary - will be in node_modules/.bin/tsx
  const tsxPath = path.join(require.resolve('tsx'), '../../dist/cli.mjs');
  const webhookServer = spawn(process.execPath, [tsxPath, '--watch', devServerFile, 'agentmark.client.ts', 'agentmark/**/*', `--webhook-port=${webhookPort}`, `--api-server-port=${apiPort}`], {
    stdio: 'inherit',
    cwd
  });

  webhookServer.on('error', (error) => {
    console.error('Failed to start webhook server:', error.message);
    if (apiServerInstance) {
      try { apiServerInstance.close(); } catch {
        // Ignore errors when closing API server
      }
    }
    process.exit(1);
  });

  webhookServer.on('exit', (code) => {
    // Only log if not shutting down intentionally
    if (!isShuttingDown) {
      if (code === 0 || code === null) {
        console.log('\nWebhook server stopped');
      } else {
        console.error(`\n‚ùå Webhook server exited with error code ${code}`);
        console.error('Check the output above for error details');
      }
      if (apiServerInstance) {
        try { apiServerInstance.close(); } catch {
          // Ignore errors when closing API server
        }
      }
      process.exit(code || 0);
    }
  });

  // Start AgentMark UI app (Next.js production server)
  const nextCwd = path.join(__dirname, '..', '..');
  let actualAppPort = appPort;
  let uiServer: ReturnType<typeof spawn> | null = null;

  async function startAgentMarkServer() {
    while (!(await isPortFree(actualAppPort))) {
      console.warn(`Port ${actualAppPort} is busy, trying ${actualAppPort + 1}`);
      actualAppPort++;
    }

    uiServer = spawn('npm', ['start', '--', '-p', `${actualAppPort}`], {
      stdio: 'pipe',
      cwd: nextCwd,
      env: {
        ...process.env,
        NEXT_PUBLIC_AGENTMARK_API_PORT: String(apiPort)
      },
    });

    // Capture output for debugging
    uiServer.stdout?.on('data', () => {
      // Silently consume stdout
    });

    uiServer.stderr?.on('data', (data) => {
      console.error(`AgentMark UI error: ${data.toString()}`);
    });

    uiServer.on('exit', (code) => {
      // Only log if not shutting down intentionally
      if (!isShuttingDown) {
        console.log(`AgentMark UI server exited with code ${code}`);
        process.exit(code || 0);
      }
    });

    uiServer.on('error', (err) => {
      console.error('Failed to start AgentMark UI server:', err.message);
      process.exit(1);
    });
  }

  // Start the AgentMark app
  startAgentMarkServer();

  // Store tunnel info for cleanup
  let tunnelInfo: TunnelInfo | null = null;

  // Give servers time to start, then print summary and optionally setup tunnel
  setTimeout(async () => {
    // Verify webhook server is still running before showing success message
    if (webhookServer.exitCode !== null) {
      console.error('\n‚ùå Webhook server failed to start');
      console.error('The API server is running, but the webhook server did not start successfully');
      return;
    }

    // Setup tunnel if requested
    if (useTunnel) {
      try {
        const subdomain = getTunnelSubdomain();
        tunnelInfo = await createTunnel(webhookPort, subdomain);
      } catch {
        console.error('Continuing without tunnel...\n');
      }
    }

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('üöÄ AgentMark Development Servers Running');
    console.log('‚ïê'.repeat(70));

    console.log(`\n  API:           http://localhost:${apiPort}`);
    console.log(`  Webhook:       http://localhost:${webhookPort}`);
    console.log(`  App:           http://localhost:${actualAppPort}`);

    if (useTunnel && tunnelInfo) {
      console.log('\n  Public Webhook:');
      console.log(`    URL:    ${tunnelInfo.url}`);
      console.log(`    Secret: ${config.webhookSecret}`);
      console.log(`    Valid:  ${getConfigDaysRemaining(config)} days remaining`);
    }

    console.log('\n' + '‚îÄ'.repeat(70));
    console.log('How to run prompts and experiments:');
    console.log('‚îÄ'.repeat(70));
    console.log('\n  Open a new terminal window and run:');
    console.log('\n  Run a prompt:');
    console.log('  $ npm run prompt ./agentmark/party-planner.prompt.mdx');
    console.log('\n  Run an experiment:');
    console.log('  $ npm run experiment ./agentmark/party-planner.prompt.mdx');
    console.log('\n  (Replace with any prompt file in ./agentmark/)');

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('Press Ctrl+C in this terminal to stop the servers');
    console.log('‚ïê'.repeat(70) + '\n');
  }, 3000);

  // Handle process termination
  const cleanup = async () => {
    if (isShuttingDown) return;
    isShuttingDown = true;

    console.log('\nShutting down servers...');

    // Close tunnel first
    if (tunnelInfo) {
      try {
        console.log('  Stopping tunnel...');
        await tunnelInfo.disconnect();
      } catch (error) {
        console.error('  Error disconnecting tunnel:', error);
      }
    }

    // Close API server with force close on all connections
    if (apiServerInstance) {
      try {
        console.log('  Stopping API server...');
        // Force close all connections
        await new Promise<void>((resolve) => {
          apiServerInstance.closeAllConnections?.();
          apiServerInstance.close(() => {
            resolve();
          });
          // Timeout in case close hangs
          setTimeout(resolve, 1000);
        });
      } catch (error) {
        console.error('  Error stopping API server:', error);
      }
    }

    // Kill webhook server process tree
    if (webhookServer.pid) {
      console.log('  Stopping webhook server...');
      killProcessTree(webhookServer.pid);
    }

    // Kill UI server process tree
    if (uiServer && uiServer.pid) {
      console.log('  Stopping UI server...');
      killProcessTree(uiServer.pid);
    }

    console.log('Servers stopped.');

    // Give processes time to die, then force exit
    // Increased timeout to allow for graceful shutdown
    setTimeout(() => {
      process.exit(0);
    }, 1000);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);

  // Don't use exit handler - it causes issues with async cleanup
  // The SIGINT/SIGTERM handlers will trigger process.exit()
};

export default dev;
