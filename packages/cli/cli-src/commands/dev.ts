import { spawn } from "child_process";
import path from "path";
import fs from "fs";
import { createApiServer } from "../api-server";
import net from "net";

function getSafeCwd(): string {
  try { return process.cwd(); } catch { return process.env.PWD || process.env.INIT_CWD || '.'; }
}

function isPortFree(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const tester = net.createServer()
      .once('error', () => resolve(false))
      .once('listening', () => tester.close(() => resolve(true)))
      .listen(port);
  });
}

const dev = async (options: { port?: number; runnerPort?: number; agentmarkAppPort?: number } = {}) => {
  const apiServerPort = options.port || 9418;
  const runnerPort = options.runnerPort || 9417;
  const agentmarkAppPort = options.agentmarkAppPort || 3000;
  const cwd = getSafeCwd();

  // Check if agentmark.client.ts exists
  const configPath = path.join(cwd, 'agentmark.client.ts');
  if (!fs.existsSync(configPath)) {
    console.error('Error: agentmark.client.ts not found in current directory');
    console.error('Run this command from your AgentMark project root');
    process.exit(1);
  }


  // Determine which dev server entry point to use
  const customDevServer = path.join(cwd, 'dev-server.ts');
  const autoGeneratedEntry = path.join(cwd, '.agentmark', 'dev-entry.ts');

  let devServerFile: string;

  if (fs.existsSync(customDevServer)) {
    console.log('Using custom dev-server.ts');
    devServerFile = customDevServer;
  } else if (fs.existsSync(autoGeneratedEntry)) {
    devServerFile = autoGeneratedEntry;
  } else {
    console.error('Error: No dev server entry point found.');
    console.error('Expected .agentmark/dev-entry.ts to be created during initialization.');
    console.error('Please run "npx create-agentmark" to set up a new project.');
    process.exit(1);
  }

  // Start API server directly
  let apiServerInstance: any;
  try {
    apiServerInstance = await createApiServer(apiServerPort);
  } catch (error: any) {
    console.error('Failed to start API server:', error.message);
    process.exit(1);
  }

  const killProcessTree = (pid: number) => {
    try {
      // Kill all children first
      try {
        spawn('pkill', ['-P', String(pid)], { stdio: 'ignore' });
      } catch {
        // Ignore errors when killing children
      }
      // Then kill the main process
      process.kill(pid, 'SIGKILL');
    } catch (_e) {
      // Ignore errors (process may already be dead)
    }
  };

  // Start runner server using local tsx installation
  // Find tsx binary - will be in node_modules/.bin/tsx
  const tsxPath = path.join(require.resolve('tsx'), '../../dist/cli.mjs');
  const runnerServer = spawn(process.execPath, [tsxPath, '--watch', devServerFile, 'agentmark.client.ts', 'agentmark/**/*', `--runner-port=${runnerPort}`, `--api-server-port=${apiServerPort}`], {
    stdio: 'inherit',
    cwd
  });

  const nextCwd = path.join(__dirname, '..', '..');

  let appPort = agentmarkAppPort;

  async function startAgentMarkServer() {
    while (!(await isPortFree(appPort))) {
      console.warn(`Port ${appPort} is busy, trying ${appPort + 1}`);
      appPort++;
    }
  
    const server = spawn('npm', ['start', '--', '--port', `${appPort}`], {
      stdio: 'pipe',
      cwd: nextCwd,
      env: { ...process.env, NEXT_PUBLIC_AGENTMARK_API_PORT: String(apiServerPort) },
    });
  
    server.on('exit', (code) => process.exit(code || 0));
    server.on('error', (err) => {
      console.error('Failed to start AgentMark server:', err.message);
      process.exit(1);
    });
  }

  // Start the first server attempt
  startAgentMarkServer();

  runnerServer.on('error', (error) => {
    console.error('Failed to start runner server:', error.message);
    if (apiServerInstance) {
      try { apiServerInstance.close(); } catch {
        // Ignore errors when closing API server
      }
    }
    process.exit(1);
  });

  runnerServer.on('exit', (code) => {
    console.log(`\nRunner server exited with code ${code}`);
    if (apiServerInstance) {
      try { apiServerInstance.close(); } catch {
        // Ignore errors when closing API server
      }
    }
    process.exit(code || 0);
  });

  // Give servers time to start, then print summary
  setTimeout(() => {
    console.log('\n' + 'â•'.repeat(70));
    console.log('ðŸš€ AgentMark Development Servers Running');
    console.log('â•'.repeat(70));
    console.log(`\n  API Server:    http://localhost:${apiServerPort}`);
    console.log(`  Runner Server: http://localhost:${runnerPort}`);
    console.log(`  AgentMark App: http://localhost:${appPort}`);
    console.log('\n' + 'â”€'.repeat(70));
    console.log('How to run prompts and experiments:');
    console.log('â”€'.repeat(70));
    console.log('\n  Open a new terminal window and run:');
    console.log('\n  Run a prompt:');
    console.log('  $ npm run prompt ./agentmark/party-planner.prompt.mdx');
    console.log('\n  Run an experiment:');
    console.log('  $ npm run experiment ./agentmark/party-planner.prompt.mdx');
    console.log('\n  (Replace with any prompt file in ./agentmark/)');
    console.log('\n' + 'â•'.repeat(70));
    console.log('Press Ctrl+C in this terminal to stop the servers');
    console.log('â•'.repeat(70) + '\n');
  }, 3000);

  // Handle process termination
  let isShuttingDown = false;
  const cleanup = () => {
    if (isShuttingDown) return;
    isShuttingDown = true;

    console.log('\nShutting down servers...');

    if (apiServerInstance) {
      try { apiServerInstance.close(); } catch {
        // Ignore errors when closing API server
      }
    }
    if (runnerServer.pid) killProcessTree(runnerServer.pid);

    setTimeout(() => process.exit(0), 500);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('exit', cleanup);
};

export default dev;
